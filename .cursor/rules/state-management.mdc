---
description: state
globs: 
alwaysApply: false
---
# State Management Architecture

Bu proje modern state management için Zustand ve TanStack Query kombinasyonunu kullanır. Bu yaklaşım, performans, developer experience ve maintainability açısından optimize edilmiştir.

## Zustand Stores

### Auth Store ([lib/stores/auth-store.ts](mdc:lib/stores/auth-store.ts))
- User authentication state
- Permission management
- Session tracking
- Persist middleware ile localStorage integration

```typescript
// Auth store kullanımı
const { user, isAuthenticated, hasPermission } = useAuth();
const setUser = useAuthStore((state) => state.setUser);
```

### UI Store ([lib/stores/ui-store.ts](mdc:lib/stores/ui-store.ts))
- Loading states management
- Modal state management
- Notification system
- Sidebar state
- Global UI interactions

```typescript
// UI store kullanımı
const { showSuccess, showError } = useUIStore();
const { isOpen, data } = useModal('userEditModal');
const isLoading = useIsLoading('userCreate');
```

## TanStack Query Integration

### Query Provider ([lib/providers/query-provider.tsx](mdc:lib/providers/query-provider.tsx))
- Enhanced query client configuration
- Global error handling
- Cache management
- Development tools integration

```typescript
// Query provider wrapping
<QueryProvider>
  <App />
</QueryProvider>
```

### API Client ([lib/api-client.ts](mdc:lib/api-client.ts))
- Modern API client with TanStack Query optimization
- Organized API functions (authAPI, usersAPI, rolesAPI)
- Query key factories for cache management
- Enhanced error handling

```typescript
// API kullanımı
const { data: users, isLoading, error } = useUsers(filters);
const createUserMutation = useCreateUser();
```

### Custom Hooks ([lib/hooks/useUsers.ts](mdc:lib/hooks/useUsers.ts))
- Enhanced query hooks
- Optimistic updates
- Cache invalidation strategies
- Error handling integration

```typescript
// User management hooks
const { data: users } = useUsers({ page: 1, limit: 10 });
const { mutate: createUser } = useCreateUser();
const { mutate: updateUser } = useUpdateUser();
```

## State Management Patterns

### 1. Client State (Zustand)
- Authentication state
- UI state (modals, loading, notifications)
- User preferences
- Temporary form state

### 2. Server State (TanStack Query)
- API data caching
- Background updates
- Optimistic updates
- Error retry logic

### 3. Form State (React Hook Form)
- Form validation
- Field state management
- Submission handling
- Error display

## Cache Management

### Query Keys ([lib/api-client.ts](mdc:lib/api-client.ts))
```typescript
export const queryKeys = {
  auth: {
    all: ["auth"] as const,
    currentUser: () => [...queryKeys.auth.all, "currentUser"] as const,
  },
  users: {
    all: ["users"] as const,
    lists: () => [...queryKeys.users.all, "list"] as const,
    list: (filters?: Record<string, unknown>) =>
      [...queryKeys.users.lists(), filters] as const,
  },
};
```

### Cache Invalidation
```typescript
// Specific invalidation
await invalidateUserQueries();
await invalidateAuthQueries();

// Global invalidation
await invalidateAllQueries();
```

### Cache Configuration ([lib/constants.ts](mdc:lib/constants.ts))
```typescript
export const CACHE_CONFIG = {
  DEFAULT_STALE_TIME: 5 * 60 * 1000, // 5 minutes
  DEFAULT_CACHE_TIME: 10 * 60 * 1000, // 10 minutes
  USERS_STALE_TIME: 30 * 1000, // 30 seconds
  // ...
};
```

## Store Patterns

### 1. Zustand Store Structure
```typescript
interface StoreState {
  // State properties
  data: DataType | null;
  isLoading: boolean;
  error: string | null;
}

interface StoreActions {
  // Actions
  setData: (data: DataType) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

type Store = StoreState & StoreActions;
```

### 2. Selector Hooks
```typescript
// Optimized selectors to prevent unnecessary re-renders
export const useUser = () => useAuthStore((state) => state.user);
export const useIsAuthenticated = () => useAuthStore((state) => state.isAuthenticated);
```

### 3. Persistence Pattern
```typescript
// Persist middleware configuration
persist(
  (set, get) => ({
    // store implementation
  }),
  {
    name: STORAGE_KEYS.AUTH_USER,
    partialize: (state) => ({
      user: state.user,
      isAuthenticated: state.isAuthenticated,
    }),
  }
)
```

## Best Practices

### 1. State Separation
- **Client State**: UI state, user preferences, temporary data
- **Server State**: API data, cached responses, background sync
- **Form State**: Form validation, field state, submission

### 2. Performance Optimization
- Use specific selectors to prevent unnecessary re-renders
- Implement optimistic updates for better UX
- Configure appropriate cache times
- Use React.memo for expensive components

### 3. Error Handling
```typescript
// Global error handling in query client
queryCache: new QueryCache({
  onError: (error, query) => {
    console.error('Query Error:', error);
    // Handle auth errors globally
    if (isAuthError(error)) {
      authActions.logout();
    }
  },
}),
```

### 4. Loading States
```typescript
// Component-specific loading states
const { isLoading, startLoading, stopLoading } = useComponentLoading('userForm');

// Global loading state
const { setLoading } = useUIStore();
setLoading('globalOperation', true);
```

### 5. Notifications
```typescript
// Success/Error notifications
const { showSuccess, showError } = useUIStore();

// In mutations
onSuccess: () => {
  showSuccess('İşlem başarılı');
  invalidateQueries(['users']);
},
onError: (error) => {
  showError('İşlem başarısız', error.message);
}
```

## Integration Examples

### Component with State Management
```typescript
function UserManagement() {
  // Server state
  const { data: users, isLoading } = useUsers();
  
  // Client state
  const { isOpen } = useModal('createUser');
  const { showSuccess } = useUIStore();
  
  // Mutations
  const { mutate: createUser } = useCreateUser();
  
  const handleCreate = (userData) => {
    createUser(userData, {
      onSuccess: () => {
        showSuccess('Kullanıcı oluşturuldu');
        closeModal('createUser');
      }
    });
  };
  
  return (
    // Component JSX
  );
}
```

Bu architecture, scalable, performant ve maintainable state management sağlar.

